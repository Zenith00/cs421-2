
==================== FINAL INTERFACE ====================
2019-04-19 21:51:37.520851 UTC

interface main:Scheme.Runtime 8063
  interface hash: f9be2da3da6d03d3c17d018d7f51dffd
  ABI hash: 522bcbb453beba0f4251c77d60afe845
  export-list hash: 8a2f1bda104d17b01f918df265ec11cf
  orphan hash: 56a9d28f013578d8f817f87d25c0e405
  flag hash: 5ca3f986bccf1939873f0a149c9a7bdc
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  Scheme.Runtime.append
  Scheme.Runtime.applyPrim
  Scheme.Runtime.car
  Scheme.Runtime.cdr
  Scheme.Runtime.cons
  Scheme.Runtime.eq
  Scheme.Runtime.equalSign
  Scheme.Runtime.evalPrim
  Scheme.Runtime.isBoolean
  Scheme.Runtime.isList
  Scheme.Runtime.isNull
  Scheme.Runtime.isNumber
  Scheme.Runtime.isPair
  Scheme.Runtime.isSymbol
  Scheme.Runtime.liftBoolUnaryOp
  Scheme.Runtime.liftBoolVargOp
  Scheme.Runtime.liftCompOp
  Scheme.Runtime.liftIntBinOp
  Scheme.Runtime.liftIntUnaryOp
  Scheme.Runtime.liftIntVargOp
  Scheme.Runtime.list
  Scheme.Runtime.lowerBool
  Scheme.Runtime.lowerInt
  Scheme.Runtime.lowerList
  Scheme.Runtime.myFoldl1
  Scheme.Runtime.runtime
module dependencies: Scheme.Core Scheme.Eval Scheme.Parse
package dependencies: array-0.5.3.0 base-4.12.0.0* binary-0.8.6.0
                      bytestring-0.10.8.2 containers-0.6.0.1 deepseq-1.4.4.0
                      ghc-prim-0.5.3 hashable-1.2.7.0 integer-gmp-1.0.2.0 mtl-2.2.2
                      parsec-3.1.13.0 text-1.2.3.1 transformers-0.5.5.0
                      unordered-containers-0.2.9.0*
orphans: hashable-1.2.7.0:Data.Hashable.Generic
         text-1.2.3.1:Data.Text.Lazy text-1.2.3.1:Data.Text
         binary-0.8.6.0:Data.Binary.Generic
         bytestring-0.10.8.2:Data.ByteString.Builder
         text-1.2.3.1:Data.Text.Show
         transformers-0.5.5.0:Control.Monad.Trans.Error
         base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Complex base-4.12.0.0:Data.Functor.Compose
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity
                         base-4.12.0.0:Data.Functor.Product base-4.12.0.0:Data.Functor.Sum
                         base-4.12.0.0:Data.Monoid base-4.12.0.0:Data.Semigroup
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:Data.Void base-4.12.0.0:GHC.Exts
                         base-4.12.0.0:GHC.Generics base-4.12.0.0:GHC.IO.Exception
                         containers-0.6.0.1:Data.IntMap.Internal
                         containers-0.6.0.1:Data.IntSet.Internal
                         containers-0.6.0.1:Data.Map.Internal
                         containers-0.6.0.1:Data.Sequence.Internal
                         containers-0.6.0.1:Data.Set.Internal containers-0.6.0.1:Data.Tree
                         text-1.2.3.1:Data.Text text-1.2.3.1:Data.Text.Lazy
                         unordered-containers-0.2.9.0:Data.HashMap.Base
import  -/  base-4.12.0.0:Control.Monad 7bd27be8172a0ce3a579caee3ae14f88
import  -/  base-4.12.0.0:Data.Foldable 00188ddf89c975fee76bdfad479443c1
import  -/  base-4.12.0.0:Data.Functor 22aac80fdb6c7b7f60b4aaab86afee64
import  -/  base-4.12.0.0:Data.Traversable 257e9f3b6739f5bfbaaf0ac0abb0ddc5
import  -/  base-4.12.0.0:GHC.Base cc906f98291a1b830546e99a96674547
import  -/  base-4.12.0.0:GHC.Num 847723f2584d989dac1eada133ac3fb8
import  -/  base-4.12.0.0:GHC.Real f7dad82c1d43d80823865d3e6c6636e0
import  -/  base-4.12.0.0:Prelude 5c01365ec01f83bd405ac01cbb9a8d76
import  -/  ghc-prim-0.5.3:GHC.Classes e0d9c979f6368701f34fa421754d2cce
import  -/  Scheme.Core bc89137f3b5e21383f319843015d4057
  exports: e90d159ae09b5b31f08cb156418b2a29
  Boolean 86fa6bcaf8d96aed65f2571eb655a4ca
  DottedList d455ab82fe449e1933007195ee1e8f7e
  Env aafa0315ee62ca72ab74b7129413e93f
  EvalState aafa0315ee62ca72ab74b7129413e93f
  List 1e61c5428b58aae69a46121a165b4ba0
  Number 05bd78a8879027d5b7e5f6817ee8a849
  PrimFunc cf8aa9ade8aa834491be2c324f1074de
  Symbol 5a0dd25e96845d34ab26214ee0aa5b65
  TypeError 16dededb72851e3371f945c2cbe0352c
  UnexpectedArgs f3ecca21500e54a3ae8d6ae49901f03e
  Val aafa0315ee62ca72ab74b7129413e93f
  flattenList ed315d0fb9f4347faa1519415c1c4fd4
import  -/  Scheme.Eval e768846dbe20ed6130d3182dbeec1b2f
  exports: 16506239b2a8a5e2fa9f7525a5cea6e2
  apply 9e098f05f42e055a7a505256a3f98da4
  eval 2381f484a18351068cd387c667269cba
import  -/  Scheme.Parse 79a798cce5d49985cb79a88322b72b80
  exports: ab51cfad0b9a4fa0c1acfcf87d3a1688
import  -/  mtl-2.2.2:Control.Monad.Error.Class 396bb83814f3ba40535fffb311f79b73
import  -/  mtl-2.2.2:Control.Monad.Except 50e515fe4eac4821a9bcec9a647f5aa7
import  -/  mtl-2.2.2:Control.Monad.State d44e211fd4e6fedd1cd68c2f55562f8e
import  -/  parsec-3.1.13.0:Text.ParserCombinators.Parsec eee8e2801311fdbcd289f8b352d3343f
import  -/  unordered-containers-0.2.9.0:Data.HashMap.Strict 382b0fb0c37f914f58f22553760567f2
2377d270ad7332bcfc7820b877d855a0
  $s$wupdateOrSnocWithKey ::
    ([GHC.Types.Char] -> v -> v -> v)
    -> [GHC.Types.Char]
    -> v
    -> Data.HashMap.Array.Array#
         (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
    -> Data.HashMap.Array.Array
         (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
  {- Arity: 4, Strictness: <L,C(C1(C1(U)))><S,1*U><L,U><S,U>,
     Inline: [2],
     Unfolding: (\ @ v
                   (w1 :: [GHC.Types.Char] -> v -> v -> v)
                   (w2 :: [GHC.Types.Char])
                   (w3 :: v)
                   (ww :: Data.HashMap.Array.Array#
                            (Data.HashMap.Base.Leaf [GHC.Types.Char] v)) ->
                 let {
                   exit :: v
                           -> Data.HashMap.Array.Array#
                                (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                           -> GHC.Prim.Int#
                           -> [GHC.Types.Char]
                           -> v
                           -> Data.HashMap.Array.Array
                                (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                     <join 5> {- Arity: 5, Strictness: <L,U><S,U><S,U><L,U><L,U> -}
                   = \ (w :: v)[OneShot]
                       (ww1 :: Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf [GHC.Types.Char] v))[OneShot]
                       (ww2 :: GHC.Prim.Int#)[OneShot]
                       (k2 :: [GHC.Types.Char])[OneShot]
                       (y :: v)[OneShot] ->
                     case GHC.Magic.runRW#
                            @ ('GHC.Types.TupleRep
                                 '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                            @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                 Data.HashMap.Array.Array
                                   (Data.HashMap.Base.Leaf [GHC.Types.Char] v) #)
                            (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                             case GHC.Prim.thawSmallArray#
                                    @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                    @ GHC.Prim.RealWorld
                                    ww1
                                    0#
                                    (GHC.Prim.sizeofSmallArray#
                                       @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                       ww1)
                                    s1 of ds2 { (#,#) ipv4 ipv5 ->
                             case GHC.Prim.writeSmallArray#
                                    @ GHC.Prim.RealWorld
                                    @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                    ipv5
                                    ww2
                                    (Data.HashMap.Base.L @ [GHC.Types.Char] @ v k2 (w1 k2 w y))
                                    ipv4 of s' { DEFAULT ->
                             case GHC.Prim.unsafeFreezeSmallArray#
                                    @ GHC.Prim.RealWorld
                                    @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                    ipv5
                                    s' of ds3 { (#,#) ipv6 ipv7 ->
                             (# ipv6,
                                Data.HashMap.Array.Array
                                  @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                  ipv7 #) } } }) of ds2 { (#,#) ipv4 ipv5 ->
                     ipv5 }
                 } in
                 letrec {
                   $wgo1 :: [GHC.Types.Char]
                            -> v
                            -> Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                            -> GHC.Prim.Int#
                            -> GHC.Prim.Int#
                            -> Data.HashMap.Array.Array
                                 (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                     <join 5> {- Arity: 5, Strictness: <S,1*U><L,U><S,U><S,U><S,U>,
                                 Inline: [2] -}
                   = \ (w :: [GHC.Types.Char])
                       (w4 :: v)
                       (ww1 :: Data.HashMap.Array.Array#
                                 (Data.HashMap.Base.Leaf [GHC.Types.Char] v))
                       (ww2 :: GHC.Prim.Int#)
                       (ww3 :: GHC.Prim.Int#) ->
                     case w of k2 { DEFAULT ->
                     case GHC.Prim.>=# ww2 ww3 of lwild {
                       DEFAULT
                       -> case GHC.Prim.indexSmallArray#
                                 @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                 ww1
                                 ww2 of ds1 { Unit# ipv3 ->
                          case ipv3 of wild1 { Data.HashMap.Base.L kx y ->
                          case GHC.Base.eqString k2 kx of wild2 {
                            GHC.Types.False -> $wgo1 k2 w4 ww1 (GHC.Prim.+# ww2 1#) ww3
                            GHC.Types.True -> exit w4 ww1 ww2 k2 y } } }
                       1#
                       -> case GHC.Magic.runRW#
                                 @ ('GHC.Types.TupleRep
                                      '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                                 @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                                      Data.HashMap.Array.Array
                                        (Data.HashMap.Base.Leaf [GHC.Types.Char] v) #)
                                 (\ (s1 :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                                  case GHC.Prim.newSmallArray#
                                         @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                         @ GHC.Prim.RealWorld
                                         (GHC.Prim.+# ww3 1#)
                                         (Data.HashMap.Array.undefinedElem
                                            @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v))
                                         s1 of ds { (#,#) ipv3 ipv4 ->
                                  case GHC.Prim.copySmallArray#
                                         @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                         @ GHC.Prim.RealWorld
                                         ww1
                                         0#
                                         ipv4
                                         0#
                                         ww3
                                         ipv3 of s2 { DEFAULT ->
                                  case GHC.Prim.writeSmallArray#
                                         @ GHC.Prim.RealWorld
                                         @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                         ipv4
                                         ww3
                                         (Data.HashMap.Base.L @ [GHC.Types.Char] @ v k2 w4)
                                         s2 of s' { DEFAULT ->
                                  case GHC.Prim.unsafeFreezeSmallArray#
                                         @ GHC.Prim.RealWorld
                                         @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                         ipv4
                                         s' of ds2 { (#,#) ipv5 ipv6 ->
                                  (# ipv5,
                                     Data.HashMap.Array.Array
                                       @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                                       ipv6 #) } } } }) of ds1 { (#,#) ipv3 ipv4 ->
                          ipv4 } } }
                 } in
                 $wgo1
                   w2
                   w3
                   ww
                   0#
                   (GHC.Prim.sizeofSmallArray#
                      @ (Data.HashMap.Base.Leaf [GHC.Types.Char] v)
                      ww)) -}
5f91911193dcc77c9a1eba8c0fb68b26
  $sunsafeInsert ::
    [GHC.Types.Char]
    -> v
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
  {- Arity: 3, Strictness: <S,U><L,U><S,U>,
     Unfolding: (\ @ v
                   (k0 :: [GHC.Types.Char])
                   (v0 :: v)
                   (m0 :: Data.HashMap.Base.HashMap [GHC.Types.Char] v) ->
                 case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             Data.HashMap.Base.HashMap [GHC.Types.Char] v #)
                        (\ (w :: GHC.Prim.State# GHC.Prim.RealWorld)[OneShot] ->
                         let {
                           exit :: GHC.Prim.Int#
                                   -> GHC.Prim.Int#
                                   -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                         Data.HashMap.Base.HashMap [GHC.Types.Char] v #)
                             <join 2> {- Arity: 2, Strictness: <S,U><S,U> -}
                           = \ (ww :: GHC.Prim.Int#)[OneShot]
                               (ww1 :: GHC.Prim.Int#)[OneShot] ->
                             Scheme.Runtime.$wpoly_go1
                               @ v
                               (GHC.Prim.int2Word#
                                  (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) ww1))
                               k0
                               v0
                               0#
                               m0
                               w
                         } in
                         letrec {
                           $wgo1 :: [GHC.Types.Char]
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.Int#
                                    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
                                          Data.HashMap.Base.HashMap [GHC.Types.Char] v #)
                             <join 3> {- Arity: 3, Strictness: <S,1*U><S,U><S,U>, Inline: [2] -}
                           = \ (w1 :: [GHC.Types.Char])
                               (ww :: GHC.Prim.Int#)
                               (ww1 :: GHC.Prim.Int#) ->
                             case w1 of wild {
                               [] -> exit ww ww1
                               : y ys
                               -> case y of wild1 { GHC.Types.C# c# ->
                                  $wgo1
                                    ys
                                    (GHC.Prim.xorI# (GHC.Prim.*# ww 16777619#) (GHC.Prim.ord# c#))
                                    (GHC.Prim.+# ww1 1#) } }
                         } in
                         $wgo1 k0 -2578643520546668380# 0#) of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
ab6f6fd18edba7770ec2028fa92ec2ed
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Scheme.Runtime.$trModule3
                   Scheme.Runtime.$trModule1) -}
6187f4d87687da7361acc8dec80f4d41
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Scheme.Runtime.$trModule2) -}
470626eac9d3963c8444d535406f7610
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Scheme.Runtime"#) -}
21e03a6c0aa61cdd89922b91e254469c
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS Scheme.Runtime.$trModule4) -}
5e56a592af09aeb7eaa983df47314115
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("main"#) -}
8b6ebc5511d44f3f3f926ce6122abe88
  $wliftBoolUnaryOp ::
    (GHC.Types.Bool -> GHC.Types.Bool)
    -> (# [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(U)>, Inline: [2],
     Unfolding: (\ (w :: GHC.Types.Bool -> GHC.Types.Bool) ->
                 let {
                   eta :: GHC.Types.Bool = w GHC.Types.True
                 } in
                 let {
                   eta1 :: Scheme.Core.Val = Scheme.Core.Boolean eta
                 } in
                 let {
                   eta2 :: GHC.Types.Bool = w GHC.Types.False
                 } in
                 let {
                   eta3 :: Scheme.Core.Val = Scheme.Core.Boolean eta2
                 } in
                 (# (\ (ds :: [Scheme.Core.Val]) (eta4 :: Scheme.Core.Env) ->
                     case ds of wild {
                       []
                       -> Scheme.Runtime.applyPrim2
                            `cast`
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <Data.Either.Either
                                       Scheme.Core.Diagnostic
                                       (Scheme.Core.Val,
                                        Data.HashMap.Base.HashMap
                                          GHC.Base.String
                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                          <Scheme.Core.Diagnostic>_N
                                                                          <Data.Functor.Identity.Identity>_R
                                                                          <(Scheme.Core.Val,
                                                                            Data.HashMap.Base.HashMap
                                                                              GHC.Base.String
                                                                              Scheme.Core.Val)>_N))
                       : ds1 ds2
                       -> case ds1 of wild1 {
                            DEFAULT
                            -> case ds2 of wild2 {
                                 []
                                 -> (Data.Either.Right
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (eta1, eta4))
                                      `cast`
                                    (Nth:3
                                         (<Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val>_R
                                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                        <Data.Either.Either
                                                           Scheme.Core.Diagnostic
                                                           (Scheme.Core.Val,
                                                            Data.HashMap.Base.HashMap
                                                              GHC.Base.String
                                                              Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Scheme.Core.Diagnostic>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(Scheme.Core.Val,
                                                                                                Data.HashMap.Base.HashMap
                                                                                                  GHC.Base.String
                                                                                                  Scheme.Core.Val)>_N)))
                                 : ipv ipv1
                                 -> (Data.Either.Left
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (Scheme.Core.UnexpectedArgs wild))
                                      `cast`
                                    (Nth:3
                                         (<Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val>_R
                                          ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                        <Data.Either.Either
                                                           Scheme.Core.Diagnostic
                                                           (Scheme.Core.Val,
                                                            Data.HashMap.Base.HashMap
                                                              GHC.Base.String
                                                              Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Scheme.Core.Diagnostic>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(Scheme.Core.Val,
                                                                                                Data.HashMap.Base.HashMap
                                                                                                  GHC.Base.String
                                                                                                  Scheme.Core.Val)>_N))) }
                            Scheme.Core.Boolean ds3
                            -> case ds3 of wild2 {
                                 GHC.Types.False
                                 -> case ds2 of wild3 {
                                      []
                                      -> (Data.Either.Right
                                            @ Scheme.Core.Diagnostic
                                            @ (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String Scheme.Core.Val)
                                            (eta3, eta4))
                                           `cast`
                                         (Nth:3
                                              (<Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val>_R
                                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                             <Data.Either.Either
                                                                Scheme.Core.Diagnostic
                                                                (Scheme.Core.Val,
                                                                 Data.HashMap.Base.HashMap
                                                                   GHC.Base.String
                                                                   Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Scheme.Core.Diagnostic>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(Scheme.Core.Val,
                                                                                                     Data.HashMap.Base.HashMap
                                                                                                       GHC.Base.String
                                                                                                       Scheme.Core.Val)>_N)))
                                      : ipv ipv1
                                      -> (Data.Either.Left
                                            @ Scheme.Core.Diagnostic
                                            @ (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String Scheme.Core.Val)
                                            (Scheme.Core.UnexpectedArgs wild))
                                           `cast`
                                         (Nth:3
                                              (<Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val>_R
                                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                             <Data.Either.Either
                                                                Scheme.Core.Diagnostic
                                                                (Scheme.Core.Val,
                                                                 Data.HashMap.Base.HashMap
                                                                   GHC.Base.String
                                                                   Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Scheme.Core.Diagnostic>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(Scheme.Core.Val,
                                                                                                     Data.HashMap.Base.HashMap
                                                                                                       GHC.Base.String
                                                                                                       Scheme.Core.Val)>_N))) }
                                 GHC.Types.True
                                 -> case ds2 of wild3 {
                                      []
                                      -> (Data.Either.Right
                                            @ Scheme.Core.Diagnostic
                                            @ (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String Scheme.Core.Val)
                                            (eta1, eta4))
                                           `cast`
                                         (Nth:3
                                              (<Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val>_R
                                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                             <Data.Either.Either
                                                                Scheme.Core.Diagnostic
                                                                (Scheme.Core.Val,
                                                                 Data.HashMap.Base.HashMap
                                                                   GHC.Base.String
                                                                   Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Scheme.Core.Diagnostic>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(Scheme.Core.Val,
                                                                                                     Data.HashMap.Base.HashMap
                                                                                                       GHC.Base.String
                                                                                                       Scheme.Core.Val)>_N)))
                                      : ipv ipv1
                                      -> (Data.Either.Left
                                            @ Scheme.Core.Diagnostic
                                            @ (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String Scheme.Core.Val)
                                            (Scheme.Core.UnexpectedArgs wild))
                                           `cast`
                                         (Nth:3
                                              (<Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val>_R
                                               ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                             <Data.Either.Either
                                                                Scheme.Core.Diagnostic
                                                                (Scheme.Core.Val,
                                                                 Data.HashMap.Base.HashMap
                                                                   GHC.Base.String
                                                                   Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                                   <Scheme.Core.Diagnostic>_N
                                                                                                   <Data.Functor.Identity.Identity>_R
                                                                                                   <(Scheme.Core.Val,
                                                                                                     Data.HashMap.Base.HashMap
                                                                                                       GHC.Base.String
                                                                                                       Scheme.Core.Val)>_N))) } } } })
                      `cast`
                    (<[Scheme.Core.Val]>_R
                     ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <Scheme.Core.Env>_N
                                   <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                                   <Scheme.Core.Val>_N)) #)) -}
a758374d76c1557b4af58cd0e12280f5
  $wliftBoolVargOp ::
    ([GHC.Types.Bool] -> GHC.Types.Bool)
    -> (# [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(U)>, Inline: [2],
     Unfolding: (\ (w :: [GHC.Types.Bool] -> GHC.Types.Bool) ->
                 (# \ (x :: [Scheme.Core.Val]) ->
                    let {
                      eta :: GHC.Types.Bool
                      = w (GHC.Base.map
                             @ Scheme.Core.Val
                             @ GHC.Types.Bool
                             Scheme.Runtime.lowerBool
                             x)
                    } in
                    let {
                      eta1 :: Scheme.Core.Val = Scheme.Core.Boolean eta
                    } in
                    (\ (eta2 :: Data.HashMap.Base.HashMap
                                  GHC.Base.String Scheme.Core.Val) ->
                     Data.Either.Right
                       @ Scheme.Core.Diagnostic
                       @ (Scheme.Core.Val,
                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                       (eta1, eta2))
                      `cast`
                    ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                      ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                    <Data.Either.Either
                                       Scheme.Core.Diagnostic
                                       (Scheme.Core.Val,
                                        Data.HashMap.Base.HashMap
                                          GHC.Base.String
                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                          <Scheme.Core.Diagnostic>_N
                                                                          <Data.Functor.Identity.Identity>_R
                                                                          <(Scheme.Core.Val,
                                                                            Data.HashMap.Base.HashMap
                                                                              GHC.Base.String
                                                                              Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                               <Data.HashMap.Base.HashMap
                                                                                                                  GHC.Base.String
                                                                                                                  Scheme.Core.Val>_N
                                                                                                               <Control.Monad.Trans.Except.ExceptT
                                                                                                                  Scheme.Core.Diagnostic
                                                                                                                  Data.Functor.Identity.Identity>_R
                                                                                                               <Scheme.Core.Val>_N)) #)) -}
d68305df91fde277ea9aca380543a03c
  $wliftCompOp ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool)
    -> (# [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(C1(U))>, Inline: [2],
     Unfolding: (\ (w :: GHC.Types.Int
                         -> GHC.Types.Int -> GHC.Types.Bool) ->
                 (# (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                     case ds of wild {
                       []
                       -> (Data.Either.Right
                             @ Scheme.Core.Diagnostic
                             @ (Scheme.Core.Val,
                                Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                             (Scheme.Runtime.isBoolean_eta, eta))
                            `cast`
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <Data.Either.Either
                                       Scheme.Core.Diagnostic
                                       (Scheme.Core.Val,
                                        Data.HashMap.Base.HashMap
                                          GHC.Base.String
                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                          <Scheme.Core.Diagnostic>_N
                                                                          <Data.Functor.Identity.Identity>_R
                                                                          <(Scheme.Core.Val,
                                                                            Data.HashMap.Base.HashMap
                                                                              GHC.Base.String
                                                                              Scheme.Core.Val)>_N))
                       : ipv ipv1
                       -> case (Scheme.Runtime.liftCompOp1 wild eta)
                                 `cast`
                               (Control.Monad.Trans.Except.N:ExceptT[0]
                                    <Scheme.Core.Diagnostic>_N
                                    <Data.Functor.Identity.Identity>_R
                                    <([GHC.Types.Int],
                                      Data.HashMap.Base.HashMap
                                        GHC.Base.String
                                        Scheme.Core.Val)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                  <Data.Either.Either
                                                                     Scheme.Core.Diagnostic
                                                                     ([GHC.Types.Int],
                                                                      Data.HashMap.Base.HashMap
                                                                        GHC.Base.String
                                                                        Scheme.Core.Val)>_R) of wild1 {
                            Data.Either.Left x
                            -> (Data.Either.Left
                                  @ Scheme.Core.Diagnostic
                                  @ (Scheme.Core.Val,
                                     Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                  x)
                                 `cast`
                               (Sym (Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either
                                            Scheme.Core.Diagnostic
                                            (Scheme.Core.Val,
                                             Data.HashMap.Base.HashMap
                                               GHC.Base.String
                                               Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Scheme.Core.Diagnostic>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(Scheme.Core.Val,
                                                                                 Data.HashMap.Base.HashMap
                                                                                   GHC.Base.String
                                                                                   Scheme.Core.Val)>_N))
                            Data.Either.Right y
                            -> (Data.Either.Right
                                  @ Scheme.Core.Diagnostic
                                  @ (Scheme.Core.Val,
                                     Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                  (Scheme.Core.Boolean
                                     (case y of wild2 { (,) a1 s' ->
                                      Scheme.Runtime.myFoldl1 w a1 }),
                                   case y of wild2 { (,) a1 s' -> s' }))
                                 `cast`
                               (Sym (Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either
                                            Scheme.Core.Diagnostic
                                            (Scheme.Core.Val,
                                             Data.HashMap.Base.HashMap
                                               GHC.Base.String
                                               Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Scheme.Core.Diagnostic>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(Scheme.Core.Val,
                                                                                 Data.HashMap.Base.HashMap
                                                                                   GHC.Base.String
                                                                                   Scheme.Core.Val)>_N)) } })
                      `cast`
                    (<[Scheme.Core.Val]>_R
                     ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <Scheme.Core.Env>_N
                                   <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                                   <Scheme.Core.Val>_N)) #)) -}
2f12bd77b3e3679104f96c806ed074ec
  $wliftIntBinOp ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
    -> (# [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(C1(U))>, Inline: [2],
     Unfolding: (\ (w :: GHC.Types.Int
                         -> GHC.Types.Int -> GHC.Types.Int) ->
                 (# (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                     case ds of wild {
                       []
                       -> Scheme.Runtime.applyPrim2
                            `cast`
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <Data.Either.Either
                                       Scheme.Core.Diagnostic
                                       (Scheme.Core.Val,
                                        Data.HashMap.Base.HashMap
                                          GHC.Base.String
                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                          <Scheme.Core.Diagnostic>_N
                                                                          <Data.Functor.Identity.Identity>_R
                                                                          <(Scheme.Core.Val,
                                                                            Data.HashMap.Base.HashMap
                                                                              GHC.Base.String
                                                                              Scheme.Core.Val)>_N))
                       : x ds1
                       -> case ds1 of wild1 {
                            []
                            -> (Data.Either.Left
                                  @ Scheme.Core.Diagnostic
                                  @ (Scheme.Core.Val,
                                     Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                  (Scheme.Core.UnexpectedArgs wild))
                                 `cast`
                               (Sym (Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either
                                            Scheme.Core.Diagnostic
                                            (Scheme.Core.Val,
                                             Data.HashMap.Base.HashMap
                                               GHC.Base.String
                                               Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Scheme.Core.Diagnostic>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(Scheme.Core.Val,
                                                                                 Data.HashMap.Base.HashMap
                                                                                   GHC.Base.String
                                                                                   Scheme.Core.Val)>_N))
                            : y ds2
                            -> case ds2 of wild2 {
                                 []
                                 -> case x of wild3 {
                                      DEFAULT
                                      -> (Data.Either.Left
                                            @ Scheme.Core.Diagnostic
                                            @ (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String Scheme.Core.Val)
                                            (Scheme.Core.TypeError wild3))
                                           `cast`
                                         (Sym (Data.Functor.Identity.N:Identity[0]
                                                   <Data.Either.Either
                                                      Scheme.Core.Diagnostic
                                                      (Scheme.Core.Val,
                                                       Data.HashMap.Base.HashMap
                                                         GHC.Base.String
                                                         Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                         <Scheme.Core.Diagnostic>_N
                                                                                         <Data.Functor.Identity.Identity>_R
                                                                                         <(Scheme.Core.Val,
                                                                                           Data.HashMap.Base.HashMap
                                                                                             GHC.Base.String
                                                                                             Scheme.Core.Val)>_N))
                                      Scheme.Core.Number i
                                      -> case y of wild4 {
                                           DEFAULT
                                           -> (Data.Either.Left
                                                 @ Scheme.Core.Diagnostic
                                                 @ (Scheme.Core.Val,
                                                    Data.HashMap.Base.HashMap
                                                      GHC.Base.String Scheme.Core.Val)
                                                 (Scheme.Core.TypeError wild4))
                                                `cast`
                                              (Sym (Data.Functor.Identity.N:Identity[0]
                                                        <Data.Either.Either
                                                           Scheme.Core.Diagnostic
                                                           (Scheme.Core.Val,
                                                            Data.HashMap.Base.HashMap
                                                              GHC.Base.String
                                                              Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Scheme.Core.Diagnostic>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(Scheme.Core.Val,
                                                                                                Data.HashMap.Base.HashMap
                                                                                                  GHC.Base.String
                                                                                                  Scheme.Core.Val)>_N))
                                           Scheme.Core.Number i1
                                           -> (Data.Either.Right
                                                 @ Scheme.Core.Diagnostic
                                                 @ (Scheme.Core.Val,
                                                    Data.HashMap.Base.HashMap
                                                      GHC.Base.String Scheme.Core.Val)
                                                 (Scheme.Core.Number (w i i1), eta))
                                                `cast`
                                              (Sym (Data.Functor.Identity.N:Identity[0]
                                                        <Data.Either.Either
                                                           Scheme.Core.Diagnostic
                                                           (Scheme.Core.Val,
                                                            Data.HashMap.Base.HashMap
                                                              GHC.Base.String
                                                              Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                              <Scheme.Core.Diagnostic>_N
                                                                                              <Data.Functor.Identity.Identity>_R
                                                                                              <(Scheme.Core.Val,
                                                                                                Data.HashMap.Base.HashMap
                                                                                                  GHC.Base.String
                                                                                                  Scheme.Core.Val)>_N)) } }
                                 : ipv ipv1
                                 -> (Data.Either.Left
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (Scheme.Core.UnexpectedArgs wild))
                                      `cast`
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <Data.Either.Either
                                                 Scheme.Core.Diagnostic
                                                 (Scheme.Core.Val,
                                                  Data.HashMap.Base.HashMap
                                                    GHC.Base.String
                                                    Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Scheme.Core.Diagnostic>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(Scheme.Core.Val,
                                                                                      Data.HashMap.Base.HashMap
                                                                                        GHC.Base.String
                                                                                        Scheme.Core.Val)>_N)) } } })
                      `cast`
                    (<[Scheme.Core.Val]>_R
                     ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <Scheme.Core.Env>_N
                                   <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                                   <Scheme.Core.Val>_N)) #)) -}
895d8d73e373e78c9aa8d1d4c54dc1f9
  $wliftIntUnaryOp ::
    (GHC.Types.Int -> GHC.Types.Int)
    -> (# [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val #)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(U)>, Inline: [2],
     Unfolding: (\ (w :: GHC.Types.Int -> GHC.Types.Int) ->
                 (# (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                     case ds of wild {
                       []
                       -> Scheme.Runtime.applyPrim2
                            `cast`
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <Data.Either.Either
                                       Scheme.Core.Diagnostic
                                       (Scheme.Core.Val,
                                        Data.HashMap.Base.HashMap
                                          GHC.Base.String
                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                          <Scheme.Core.Diagnostic>_N
                                                                          <Data.Functor.Identity.Identity>_R
                                                                          <(Scheme.Core.Val,
                                                                            Data.HashMap.Base.HashMap
                                                                              GHC.Base.String
                                                                              Scheme.Core.Val)>_N))
                       : x ds1
                       -> case ds1 of wild1 {
                            []
                            -> case x of wild2 {
                                 DEFAULT
                                 -> (Data.Either.Left
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (Scheme.Core.TypeError wild2))
                                      `cast`
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <Data.Either.Either
                                                 Scheme.Core.Diagnostic
                                                 (Scheme.Core.Val,
                                                  Data.HashMap.Base.HashMap
                                                    GHC.Base.String
                                                    Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Scheme.Core.Diagnostic>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(Scheme.Core.Val,
                                                                                      Data.HashMap.Base.HashMap
                                                                                        GHC.Base.String
                                                                                        Scheme.Core.Val)>_N))
                                 Scheme.Core.Number i
                                 -> (Data.Either.Right
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (Scheme.Core.Number (w i), eta))
                                      `cast`
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <Data.Either.Either
                                                 Scheme.Core.Diagnostic
                                                 (Scheme.Core.Val,
                                                  Data.HashMap.Base.HashMap
                                                    GHC.Base.String
                                                    Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Scheme.Core.Diagnostic>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(Scheme.Core.Val,
                                                                                      Data.HashMap.Base.HashMap
                                                                                        GHC.Base.String
                                                                                        Scheme.Core.Val)>_N)) }
                            : ipv ipv1
                            -> (Data.Either.Left
                                  @ Scheme.Core.Diagnostic
                                  @ (Scheme.Core.Val,
                                     Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                  (Scheme.Core.UnexpectedArgs wild))
                                 `cast`
                               (Sym (Data.Functor.Identity.N:Identity[0]
                                         <Data.Either.Either
                                            Scheme.Core.Diagnostic
                                            (Scheme.Core.Val,
                                             Data.HashMap.Base.HashMap
                                               GHC.Base.String
                                               Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                               <Scheme.Core.Diagnostic>_N
                                                                               <Data.Functor.Identity.Identity>_R
                                                                               <(Scheme.Core.Val,
                                                                                 Data.HashMap.Base.HashMap
                                                                                   GHC.Base.String
                                                                                   Scheme.Core.Val)>_N)) } })
                      `cast`
                    (<[Scheme.Core.Val]>_R
                     ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <Scheme.Core.Env>_N
                                   <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                                   <Scheme.Core.Val>_N)) #)) -}
daa14430de63a500a5f38f6d3098828d
  $wliftIntVargOp ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int
    -> (# [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val #)
  {- Arity: 2, Strictness: <L,C(C(U))><L,U>, Inline: [2],
     Unfolding: (\ (w :: GHC.Types.Int
                         -> GHC.Types.Int -> GHC.Types.Int)
                   (w1 :: GHC.Types.Int) ->
                 let {
                   eta :: Scheme.Core.Val = Scheme.Core.Number w1
                 } in
                 let {
                   g :: GHC.Types.Int -> GHC.Types.Int = w w1
                 } in
                 (# (\ (ds :: [Scheme.Core.Val]) (eta1 :: Scheme.Core.Env) ->
                     case ds of wild {
                       []
                       -> (Data.Either.Right
                             @ Scheme.Core.Diagnostic
                             @ (Scheme.Core.Val,
                                Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                             (eta, eta1))
                            `cast`
                          (Sym (Data.Functor.Identity.N:Identity[0]
                                    <Data.Either.Either
                                       Scheme.Core.Diagnostic
                                       (Scheme.Core.Val,
                                        Data.HashMap.Base.HashMap
                                          GHC.Base.String
                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                          <Scheme.Core.Diagnostic>_N
                                                                          <Data.Functor.Identity.Identity>_R
                                                                          <(Scheme.Core.Val,
                                                                            Data.HashMap.Base.HashMap
                                                                              GHC.Base.String
                                                                              Scheme.Core.Val)>_N))
                       : x ds1
                       -> case ds1 of wild1 {
                            []
                            -> case x of wild2 {
                                 DEFAULT
                                 -> (Data.Either.Left
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (Scheme.Core.TypeError wild2))
                                      `cast`
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <Data.Either.Either
                                                 Scheme.Core.Diagnostic
                                                 (Scheme.Core.Val,
                                                  Data.HashMap.Base.HashMap
                                                    GHC.Base.String
                                                    Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Scheme.Core.Diagnostic>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(Scheme.Core.Val,
                                                                                      Data.HashMap.Base.HashMap
                                                                                        GHC.Base.String
                                                                                        Scheme.Core.Val)>_N))
                                 Scheme.Core.Number i
                                 -> (Data.Either.Right
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (Scheme.Core.Number (g i), eta1))
                                      `cast`
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <Data.Either.Either
                                                 Scheme.Core.Diagnostic
                                                 (Scheme.Core.Val,
                                                  Data.HashMap.Base.HashMap
                                                    GHC.Base.String
                                                    Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Scheme.Core.Diagnostic>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(Scheme.Core.Val,
                                                                                      Data.HashMap.Base.HashMap
                                                                                        GHC.Base.String
                                                                                        Scheme.Core.Val)>_N)) }
                            : ipv ipv1
                            -> case (Scheme.Runtime.liftCompOp1 wild eta1)
                                      `cast`
                                    (Control.Monad.Trans.Except.N:ExceptT[0]
                                         <Scheme.Core.Diagnostic>_N
                                         <Data.Functor.Identity.Identity>_R
                                         <([GHC.Types.Int],
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String
                                             Scheme.Core.Val)>_N ; Data.Functor.Identity.N:Identity[0]
                                                                       <Data.Either.Either
                                                                          Scheme.Core.Diagnostic
                                                                          ([GHC.Types.Int],
                                                                           Data.HashMap.Base.HashMap
                                                                             GHC.Base.String
                                                                             Scheme.Core.Val)>_R) of wild2 {
                                 Data.Either.Left x1
                                 -> (Data.Either.Left
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       x1)
                                      `cast`
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <Data.Either.Either
                                                 Scheme.Core.Diagnostic
                                                 (Scheme.Core.Val,
                                                  Data.HashMap.Base.HashMap
                                                    GHC.Base.String
                                                    Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Scheme.Core.Diagnostic>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(Scheme.Core.Val,
                                                                                      Data.HashMap.Base.HashMap
                                                                                        GHC.Base.String
                                                                                        Scheme.Core.Val)>_N))
                                 Data.Either.Right y
                                 -> (Data.Either.Right
                                       @ Scheme.Core.Diagnostic
                                       @ (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                       (Scheme.Core.Number
                                          (case y of wild3 { (,) a1 s' ->
                                           case a1 of wild4 {
                                             [] -> GHC.List.foldl2 @ GHC.Types.Int
                                             : x1 xs
                                             -> GHC.List.foldl
                                                  @ GHC.Types.Int
                                                  @ GHC.Types.Int
                                                  w
                                                  x1
                                                  xs } }),
                                        case y of wild3 { (,) a1 s' -> s' }))
                                      `cast`
                                    (Sym (Data.Functor.Identity.N:Identity[0]
                                              <Data.Either.Either
                                                 Scheme.Core.Diagnostic
                                                 (Scheme.Core.Val,
                                                  Data.HashMap.Base.HashMap
                                                    GHC.Base.String
                                                    Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                    <Scheme.Core.Diagnostic>_N
                                                                                    <Data.Functor.Identity.Identity>_R
                                                                                    <(Scheme.Core.Val,
                                                                                      Data.HashMap.Base.HashMap
                                                                                        GHC.Base.String
                                                                                        Scheme.Core.Val)>_N)) } } })
                      `cast`
                    (<[Scheme.Core.Val]>_R
                     ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                   <Scheme.Core.Env>_N
                                   <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                                   <Scheme.Core.Val>_N)) #)) -}
a5940514184a84be8b569e207672711a
  $wpoly_go1 ::
    GHC.Prim.Word#
    -> [GHC.Types.Char]
    -> v
    -> GHC.Prim.Int#
    -> Data.HashMap.Base.HashMap [GHC.Types.Char] v
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          Data.HashMap.Base.HashMap [GHC.Types.Char] v #)
  {- Arity: 6, Strictness: <L,U><S,1*U><L,U><L,U><S,1*U><L,U>,
     Inline: [2] -}
7f803bf1bd5bde036cf5101d2f5797d0
  append ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.append2
                        `cast`
                      ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                        ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Scheme.Core.Diagnostic
                                         (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap
                                            GHC.Base.String
                                            Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                            <Scheme.Core.Diagnostic>_N
                                                                            <Data.Functor.Identity.Identity>_R
                                                                            <(Scheme.Core.Val,
                                                                              Data.HashMap.Base.HashMap
                                                                                GHC.Base.String
                                                                                Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                 <Data.HashMap.Base.HashMap
                                                                                                                    GHC.Base.String
                                                                                                                    Scheme.Core.Val>_N
                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                    Scheme.Core.Diagnostic
                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                 <Scheme.Core.Val>_N))
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> (\ (eta1 :: Data.HashMap.Base.HashMap
                                         GHC.Base.String Scheme.Core.Val) ->
                            Data.Either.Right
                              @ Scheme.Core.Diagnostic
                              @ (Scheme.Core.Val,
                                 Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                              (x, eta1))
                             `cast`
                           ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                           <Data.Either.Either
                                              Scheme.Core.Diagnostic
                                              (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String
                                                 Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                 <Scheme.Core.Diagnostic>_N
                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                 <(Scheme.Core.Val,
                                                                                   Data.HashMap.Base.HashMap
                                                                                     GHC.Base.String
                                                                                     Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                      <Data.HashMap.Base.HashMap
                                                                                                                         GHC.Base.String
                                                                                                                         Scheme.Core.Val>_N
                                                                                                                      <Control.Monad.Trans.Except.ExceptT
                                                                                                                         Scheme.Core.Diagnostic
                                                                                                                         Data.Functor.Identity.Identity>_R
                                                                                                                      <Scheme.Core.Val>_N))
                        : ipv ipv1
                        -> Scheme.Runtime.append_go wild Scheme.Runtime.append1 } }) -}
f9e660dd56c40ddf862bffa3a86eab80
  append1 :: Scheme.Core.Val
  {- HasNoCafRefs, Strictness: m4,
     Unfolding: (Scheme.Core.List (GHC.Types.[] @ Scheme.Core.Val)) -}
1f4ce5e8e9b3a623be5c710b19d9e1d7
  append2 ::
    Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val
    -> Data.Either.Either
         Scheme.Core.Diagnostic
         (Scheme.Core.Val,
          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (1, True, False)
                (\ (eta1 :: Data.HashMap.Base.HashMap
                              GHC.Base.String Scheme.Core.Val) ->
                 Data.Either.Right
                   @ Scheme.Core.Diagnostic
                   @ (Scheme.Core.Val,
                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                   (Scheme.Runtime.append1, eta1)) -}
a017e320be3e009d054d7628be04233b
  append_go ::
    [Scheme.Core.Val]
    -> Scheme.Core.Val
    -> Control.Monad.Trans.State.Lazy.StateT
         Scheme.Core.Env
         (Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic)
         Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
0ac5b21117bd9f5517ebb4431c074409
  applyPrim ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim1
                        `cast`
                      ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                        ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Scheme.Core.Diagnostic
                                         (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap
                                            GHC.Base.String
                                            Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                            <Scheme.Core.Diagnostic>_N
                                                                            <Data.Functor.Identity.Identity>_R
                                                                            <(Scheme.Core.Val,
                                                                              Data.HashMap.Base.HashMap
                                                                                GHC.Base.String
                                                                                Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                 <Data.HashMap.Base.HashMap
                                                                                                                    GHC.Base.String
                                                                                                                    Scheme.Core.Val>_N
                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                    Scheme.Core.Diagnostic
                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                 <Scheme.Core.Val>_N))
                   : f ds1
                   -> case ds1 of wild1 {
                        []
                        -> let {
                             m1 :: Scheme.Core.Diagnostic = Scheme.Core.UnexpectedArgs wild
                           } in
                           let {
                             lvl60 :: Data.Either.Either
                                        Scheme.Core.Diagnostic
                                        (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                             = Data.Either.Left
                                 @ Scheme.Core.Diagnostic
                                 @ (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                 m1
                           } in
                           (\ (s1 :: Data.HashMap.Base.HashMap
                                       GHC.Base.String Scheme.Core.Val) ->
                            lvl60)
                             `cast`
                           ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                           <Data.Either.Either
                                              Scheme.Core.Diagnostic
                                              (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String
                                                 Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                 <Scheme.Core.Diagnostic>_N
                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                 <(Scheme.Core.Val,
                                                                                   Data.HashMap.Base.HashMap
                                                                                     GHC.Base.String
                                                                                     Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                      <Data.HashMap.Base.HashMap
                                                                                                                         GHC.Base.String
                                                                                                                         Scheme.Core.Val>_N
                                                                                                                      <Control.Monad.Trans.Except.ExceptT
                                                                                                                         Scheme.Core.Diagnostic
                                                                                                                         Data.Functor.Identity.Identity>_R
                                                                                                                      <Scheme.Core.Val>_N))
                        : ds2 ds3
                        -> case ds2 of wild2 {
                             DEFAULT
                             -> let {
                                  m1 :: Scheme.Core.Diagnostic = Scheme.Core.UnexpectedArgs wild
                                } in
                                let {
                                  lvl60 :: Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String Scheme.Core.Val)
                                  = Data.Either.Left
                                      @ Scheme.Core.Diagnostic
                                      @ (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                      m1
                                } in
                                (\ (s1 :: Data.HashMap.Base.HashMap
                                            GHC.Base.String Scheme.Core.Val) ->
                                 lvl60)
                                  `cast`
                                ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                <Data.Either.Either
                                                   Scheme.Core.Diagnostic
                                                   (Scheme.Core.Val,
                                                    Data.HashMap.Base.HashMap
                                                      GHC.Base.String
                                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                      <Scheme.Core.Diagnostic>_N
                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                      <(Scheme.Core.Val,
                                                                                        Data.HashMap.Base.HashMap
                                                                                          GHC.Base.String
                                                                                          Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                           <Data.HashMap.Base.HashMap
                                                                                                                              GHC.Base.String
                                                                                                                              Scheme.Core.Val>_N
                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                              Scheme.Core.Diagnostic
                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                           <Scheme.Core.Val>_N))
                             Scheme.Core.List prams
                             -> case ds3 of wild3 {
                                  [] -> Scheme.Eval.apply f prams
                                  : ipv ipv1
                                  -> let {
                                       m1 :: Scheme.Core.Diagnostic
                                       = Scheme.Core.UnexpectedArgs wild
                                     } in
                                     let {
                                       lvl60 :: Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String Scheme.Core.Val)
                                       = Data.Either.Left
                                           @ Scheme.Core.Diagnostic
                                           @ (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String Scheme.Core.Val)
                                           m1
                                     } in
                                     (\ (s1 :: Data.HashMap.Base.HashMap
                                                 GHC.Base.String Scheme.Core.Val) ->
                                      lvl60)
                                       `cast`
                                     ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                     <Data.Either.Either
                                                        Scheme.Core.Diagnostic
                                                        (Scheme.Core.Val,
                                                         Data.HashMap.Base.HashMap
                                                           GHC.Base.String
                                                           Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                           <Scheme.Core.Diagnostic>_N
                                                                                           <Data.Functor.Identity.Identity>_R
                                                                                           <(Scheme.Core.Val,
                                                                                             Data.HashMap.Base.HashMap
                                                                                               GHC.Base.String
                                                                                               Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                                <Data.HashMap.Base.HashMap
                                                                                                                                   GHC.Base.String
                                                                                                                                   Scheme.Core.Val>_N
                                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                                   Scheme.Core.Diagnostic
                                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                                <Scheme.Core.Val>_N)) } } } }) -}
68a418dc045770ec1b2c3934702066fb
  applyPrim1 ::
    Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val
    -> Data.Either.Either
         Scheme.Core.Diagnostic
         (Scheme.Core.Val,
          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>m1,
     Unfolding: InlineRule (1, True, True)
                (\ (s1 :: Data.HashMap.Base.HashMap
                            GHC.Base.String Scheme.Core.Val) ->
                 Scheme.Runtime.applyPrim2) -}
fb720ff05778917f18e09a690b83f6d6
  applyPrim2 ::
    Data.Either.Either
      Scheme.Core.Diagnostic
      (Scheme.Core.Val,
       Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Data.Either.Left
                   @ Scheme.Core.Diagnostic
                   @ (Scheme.Core.Val,
                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                   Scheme.Runtime.applyPrim3) -}
64fb00a4e810a2e3aa2c8d6d8b3ab22c
  applyPrim3 :: Scheme.Core.Diagnostic
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (Scheme.Core.UnexpectedArgs
                   (GHC.Types.[] @ Scheme.Core.Val)) -}
7c552894ec4be257ca666ea063a9d684
  car :: [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.car1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
d17bbcbc962d39600a3326fb284c0a3d
  car1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> (Data.Either.Left
                              @ Scheme.Core.Diagnostic
                              @ (Scheme.Core.Val,
                                 Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                              (Scheme.Core.UnexpectedArgs wild))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Scheme.Core.Diagnostic
                                        (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap
                                           GHC.Base.String
                                           Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Scheme.Core.Diagnostic>_N
                                                                           <Data.Functor.Identity.Identity>_R
                                                                           <(Scheme.Core.Val,
                                                                             Data.HashMap.Base.HashMap
                                                                               GHC.Base.String
                                                                               Scheme.Core.Val)>_N))
                        Scheme.Core.List ds3
                        -> case ds3 of wild2 {
                             []
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : x xs
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (x, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) } }
                        Scheme.Core.DottedList ds3 y
                        -> case ds3 of wild2 {
                             []
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (y, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) }
                             : x xs
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (x, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) } } } }) -}
6a60741cba11e4d1206fda535caa2e8c
  cdr :: [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.cdr1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
661facd7c8b8b81635ceaed837765207
  cdr1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> (Data.Either.Left
                              @ Scheme.Core.Diagnostic
                              @ (Scheme.Core.Val,
                                 Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                              (Scheme.Core.UnexpectedArgs wild))
                             `cast`
                           (Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Scheme.Core.Diagnostic
                                        (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap
                                           GHC.Base.String
                                           Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Scheme.Core.Diagnostic>_N
                                                                           <Data.Functor.Identity.Identity>_R
                                                                           <(Scheme.Core.Val,
                                                                             Data.HashMap.Base.HashMap
                                                                               GHC.Base.String
                                                                               Scheme.Core.Val)>_N))
                        Scheme.Core.List ds3
                        -> case ds3 of wild2 {
                             []
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : x xs
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.List xs, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) } }
                        Scheme.Core.DottedList ds3 y
                        -> case ds3 of wild2 {
                             []
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (y, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) }
                             : x xs
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.DottedList xs y, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) } } } }) -}
81b137e58e45e6026aeeeec41bf35de6
  cons :: [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim1
                        `cast`
                      ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                        ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Scheme.Core.Diagnostic
                                         (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap
                                            GHC.Base.String
                                            Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                            <Scheme.Core.Diagnostic>_N
                                                                            <Data.Functor.Identity.Identity>_R
                                                                            <(Scheme.Core.Val,
                                                                              Data.HashMap.Base.HashMap
                                                                                GHC.Base.String
                                                                                Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                 <Data.HashMap.Base.HashMap
                                                                                                                    GHC.Base.String
                                                                                                                    Scheme.Core.Val>_N
                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                    Scheme.Core.Diagnostic
                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                 <Scheme.Core.Val>_N))
                   : x ds1
                   -> case ds1 of wild1 {
                        []
                        -> let {
                             m1 :: Scheme.Core.Diagnostic = Scheme.Core.UnexpectedArgs wild
                           } in
                           let {
                             lvl60 :: Data.Either.Either
                                        Scheme.Core.Diagnostic
                                        (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                             = Data.Either.Left
                                 @ Scheme.Core.Diagnostic
                                 @ (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                 m1
                           } in
                           (\ (s1 :: Data.HashMap.Base.HashMap
                                       GHC.Base.String Scheme.Core.Val) ->
                            lvl60)
                             `cast`
                           ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                           <Data.Either.Either
                                              Scheme.Core.Diagnostic
                                              (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String
                                                 Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                 <Scheme.Core.Diagnostic>_N
                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                 <(Scheme.Core.Val,
                                                                                   Data.HashMap.Base.HashMap
                                                                                     GHC.Base.String
                                                                                     Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                      <Data.HashMap.Base.HashMap
                                                                                                                         GHC.Base.String
                                                                                                                         Scheme.Core.Val>_N
                                                                                                                      <Control.Monad.Trans.Except.ExceptT
                                                                                                                         Scheme.Core.Diagnostic
                                                                                                                         Data.Functor.Identity.Identity>_R
                                                                                                                      <Scheme.Core.Val>_N))
                        : y ds2
                        -> case ds2 of wild2 {
                             []
                             -> let {
                                  eta :: Scheme.Core.Val
                                  = Scheme.Core.flattenList
                                      (Scheme.Core.DottedList
                                         (GHC.Types.:
                                            @ Scheme.Core.Val
                                            x
                                            (GHC.Types.[] @ Scheme.Core.Val))
                                         y)
                                } in
                                (\ (eta1 :: Data.HashMap.Base.HashMap
                                              GHC.Base.String Scheme.Core.Val) ->
                                 Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (eta, eta1))
                                  `cast`
                                ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                <Data.Either.Either
                                                   Scheme.Core.Diagnostic
                                                   (Scheme.Core.Val,
                                                    Data.HashMap.Base.HashMap
                                                      GHC.Base.String
                                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                      <Scheme.Core.Diagnostic>_N
                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                      <(Scheme.Core.Val,
                                                                                        Data.HashMap.Base.HashMap
                                                                                          GHC.Base.String
                                                                                          Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                           <Data.HashMap.Base.HashMap
                                                                                                                              GHC.Base.String
                                                                                                                              Scheme.Core.Val>_N
                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                              Scheme.Core.Diagnostic
                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                           <Scheme.Core.Val>_N))
                             : ipv ipv1
                             -> let {
                                  m1 :: Scheme.Core.Diagnostic = Scheme.Core.UnexpectedArgs wild
                                } in
                                let {
                                  lvl60 :: Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String Scheme.Core.Val)
                                  = Data.Either.Left
                                      @ Scheme.Core.Diagnostic
                                      @ (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                      m1
                                } in
                                (\ (s1 :: Data.HashMap.Base.HashMap
                                            GHC.Base.String Scheme.Core.Val) ->
                                 lvl60)
                                  `cast`
                                ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                                  ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                                <Data.Either.Either
                                                   Scheme.Core.Diagnostic
                                                   (Scheme.Core.Val,
                                                    Data.HashMap.Base.HashMap
                                                      GHC.Base.String
                                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                      <Scheme.Core.Diagnostic>_N
                                                                                      <Data.Functor.Identity.Identity>_R
                                                                                      <(Scheme.Core.Val,
                                                                                        Data.HashMap.Base.HashMap
                                                                                          GHC.Base.String
                                                                                          Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                           <Data.HashMap.Base.HashMap
                                                                                                                              GHC.Base.String
                                                                                                                              Scheme.Core.Val>_N
                                                                                                                           <Control.Monad.Trans.Except.ExceptT
                                                                                                                              Scheme.Core.Diagnostic
                                                                                                                              Data.Functor.Identity.Identity>_R
                                                                                                                           <Scheme.Core.Val>_N)) } } }) -}
d2bcbf49163a9eec730c1cb89e7ebf21
  eq :: [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
c7f4d046fc2f0658675e46b6b56f7715
  equalSign ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U> -}
a39aaf47c6ca42137dea343a725e09b8
  evalPrim ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim1
                        `cast`
                      ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                        ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                      <Data.Either.Either
                                         Scheme.Core.Diagnostic
                                         (Scheme.Core.Val,
                                          Data.HashMap.Base.HashMap
                                            GHC.Base.String
                                            Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                            <Scheme.Core.Diagnostic>_N
                                                                            <Data.Functor.Identity.Identity>_R
                                                                            <(Scheme.Core.Val,
                                                                              Data.HashMap.Base.HashMap
                                                                                GHC.Base.String
                                                                                Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                 <Data.HashMap.Base.HashMap
                                                                                                                    GHC.Base.String
                                                                                                                    Scheme.Core.Val>_N
                                                                                                                 <Control.Monad.Trans.Except.ExceptT
                                                                                                                    Scheme.Core.Diagnostic
                                                                                                                    Data.Functor.Identity.Identity>_R
                                                                                                                 <Scheme.Core.Val>_N))
                   : e ds1
                   -> case ds1 of wild1 {
                        [] -> Scheme.Eval.eval e
                        : ipv ipv1
                        -> let {
                             m1 :: Scheme.Core.Diagnostic = Scheme.Core.UnexpectedArgs wild
                           } in
                           let {
                             lvl60 :: Data.Either.Either
                                        Scheme.Core.Diagnostic
                                        (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                             = Data.Either.Left
                                 @ Scheme.Core.Diagnostic
                                 @ (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                 m1
                           } in
                           (\ (s1 :: Data.HashMap.Base.HashMap
                                       GHC.Base.String Scheme.Core.Val) ->
                            lvl60)
                             `cast`
                           ((<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                             ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                           <Data.Either.Either
                                              Scheme.Core.Diagnostic
                                              (Scheme.Core.Val,
                                               Data.HashMap.Base.HashMap
                                                 GHC.Base.String
                                                 Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                 <Scheme.Core.Diagnostic>_N
                                                                                 <Data.Functor.Identity.Identity>_R
                                                                                 <(Scheme.Core.Val,
                                                                                   Data.HashMap.Base.HashMap
                                                                                     GHC.Base.String
                                                                                     Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                      <Data.HashMap.Base.HashMap
                                                                                                                         GHC.Base.String
                                                                                                                         Scheme.Core.Val>_N
                                                                                                                      <Control.Monad.Trans.Except.ExceptT
                                                                                                                         Scheme.Core.Diagnostic
                                                                                                                         Data.Functor.Identity.Identity>_R
                                                                                                                      <Scheme.Core.Val>_N)) } }) -}
ea0f95842076da9d3fe56c5a337628c8
  isBoolean ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.isBoolean1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
33f5100b1a1d68c148b9f76aaf0fbcaf
  isBoolean1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean2, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) }
                        Scheme.Core.Boolean ds3
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean_eta, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) } } }) -}
4756bb3a7c09e6c43a23acca9ff8f492
  isBoolean2 :: Scheme.Core.Val
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Scheme.Core.Boolean GHC.Types.False) -}
fb9b5ef29570e379bf8a0f6dcae4dcb6
  isBoolean_eta :: Scheme.Core.Val
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (Scheme.Core.Boolean GHC.Types.True) -}
239a27fff0e57e94e476bfee45550fdd
  isList ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.isList1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
d4f8978d77b11523c7d20b6012317392
  isList1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean2, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) }
                        Scheme.Core.List ds3
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean_eta, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) } } }) -}
f463e5a628060a404827807dc1b98834
  isNull ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.isNull1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
fe786f125b324195f01483a11c1f1ebc
  isNull1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean2, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) }
                        Scheme.Core.List ds3
                        -> case ds3 of wild2 {
                             []
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Runtime.isBoolean_eta, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) }
                             : ipv ipv1
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Runtime.isBoolean2, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv2 ipv3
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) } } } }) -}
01037069fbc275eacb0b28ac0126d647
  isNumber ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.isNumber1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
4af83a9190ea1a5553de4e20b0834fe7
  isNumber1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean2, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) }
                        Scheme.Core.Number ds3
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean_eta, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) } } }) -}
c40b7972933ebfafab351c671a5b8cc7
  isPair ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.isPair1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
2217e05247a4abc24aafe96b008b4b5c
  isPair1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean2, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) }
                        Scheme.Core.List ds3
                        -> case ds3 of wild2 {
                             []
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Runtime.isBoolean2, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) }
                             : x ds4
                             -> case ds4 of wild3 {
                                  []
                                  -> case ds2 of wild4 {
                                       []
                                       -> (Data.Either.Right
                                             @ Scheme.Core.Diagnostic
                                             @ (Scheme.Core.Val,
                                                Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val)
                                             (Scheme.Runtime.isBoolean2, eta))
                                            `cast`
                                          (Sym (Data.Functor.Identity.N:Identity[0]
                                                    <Data.Either.Either
                                                       Scheme.Core.Diagnostic
                                                       (Scheme.Core.Val,
                                                        Data.HashMap.Base.HashMap
                                                          GHC.Base.String
                                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                          <Scheme.Core.Diagnostic>_N
                                                                                          <Data.Functor.Identity.Identity>_R
                                                                                          <(Scheme.Core.Val,
                                                                                            Data.HashMap.Base.HashMap
                                                                                              GHC.Base.String
                                                                                              Scheme.Core.Val)>_N))
                                       : ipv ipv1
                                       -> (Data.Either.Left
                                             @ Scheme.Core.Diagnostic
                                             @ (Scheme.Core.Val,
                                                Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val)
                                             (Scheme.Core.UnexpectedArgs wild))
                                            `cast`
                                          (Sym (Data.Functor.Identity.N:Identity[0]
                                                    <Data.Either.Either
                                                       Scheme.Core.Diagnostic
                                                       (Scheme.Core.Val,
                                                        Data.HashMap.Base.HashMap
                                                          GHC.Base.String
                                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                          <Scheme.Core.Diagnostic>_N
                                                                                          <Data.Functor.Identity.Identity>_R
                                                                                          <(Scheme.Core.Val,
                                                                                            Data.HashMap.Base.HashMap
                                                                                              GHC.Base.String
                                                                                              Scheme.Core.Val)>_N)) }
                                  : ipv ipv1
                                  -> case ds2 of wild4 {
                                       []
                                       -> (Data.Either.Right
                                             @ Scheme.Core.Diagnostic
                                             @ (Scheme.Core.Val,
                                                Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val)
                                             (Scheme.Runtime.isBoolean_eta, eta))
                                            `cast`
                                          (Sym (Data.Functor.Identity.N:Identity[0]
                                                    <Data.Either.Either
                                                       Scheme.Core.Diagnostic
                                                       (Scheme.Core.Val,
                                                        Data.HashMap.Base.HashMap
                                                          GHC.Base.String
                                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                          <Scheme.Core.Diagnostic>_N
                                                                                          <Data.Functor.Identity.Identity>_R
                                                                                          <(Scheme.Core.Val,
                                                                                            Data.HashMap.Base.HashMap
                                                                                              GHC.Base.String
                                                                                              Scheme.Core.Val)>_N))
                                       : ipv2 ipv3
                                       -> (Data.Either.Left
                                             @ Scheme.Core.Diagnostic
                                             @ (Scheme.Core.Val,
                                                Data.HashMap.Base.HashMap
                                                  GHC.Base.String Scheme.Core.Val)
                                             (Scheme.Core.UnexpectedArgs wild))
                                            `cast`
                                          (Sym (Data.Functor.Identity.N:Identity[0]
                                                    <Data.Either.Either
                                                       Scheme.Core.Diagnostic
                                                       (Scheme.Core.Val,
                                                        Data.HashMap.Base.HashMap
                                                          GHC.Base.String
                                                          Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                          <Scheme.Core.Diagnostic>_N
                                                                                          <Data.Functor.Identity.Identity>_R
                                                                                          <(Scheme.Core.Val,
                                                                                            Data.HashMap.Base.HashMap
                                                                                              GHC.Base.String
                                                                                              Scheme.Core.Val)>_N)) } } }
                        Scheme.Core.DottedList ds3 x
                        -> case ds3 of wild2 {
                             []
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Runtime.isBoolean2, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv ipv1
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) }
                             : ipv ipv1
                             -> case ds2 of wild3 {
                                  []
                                  -> (Data.Either.Right
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Runtime.isBoolean_eta, eta))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N))
                                  : ipv2 ipv3
                                  -> (Data.Either.Left
                                        @ Scheme.Core.Diagnostic
                                        @ (Scheme.Core.Val,
                                           Data.HashMap.Base.HashMap
                                             GHC.Base.String Scheme.Core.Val)
                                        (Scheme.Core.UnexpectedArgs wild))
                                       `cast`
                                     (Sym (Data.Functor.Identity.N:Identity[0]
                                               <Data.Either.Either
                                                  Scheme.Core.Diagnostic
                                                  (Scheme.Core.Val,
                                                   Data.HashMap.Base.HashMap
                                                     GHC.Base.String
                                                     Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                     <Scheme.Core.Diagnostic>_N
                                                                                     <Data.Functor.Identity.Identity>_R
                                                                                     <(Scheme.Core.Val,
                                                                                       Data.HashMap.Base.HashMap
                                                                                         GHC.Base.String
                                                                                         Scheme.Core.Val)>_N)) } } } }) -}
bea24a4f8d364d3160dc39034d8ac1ab
  isSymbol ::
    [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.isSymbol1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <Scheme.Core.Val>_N)) -}
0893884a7087775f3baa732800d29e07
  isSymbol1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (Scheme.Core.Val, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ (ds :: [Scheme.Core.Val]) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   []
                   -> Scheme.Runtime.applyPrim2
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (Scheme.Core.Val,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(Scheme.Core.Val,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   : ds1 ds2
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean2, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) }
                        Scheme.Core.Symbol ds3
                        -> case ds2 of wild2 {
                             []
                             -> (Data.Either.Right
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Runtime.isBoolean_eta, eta))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N))
                             : ipv ipv1
                             -> (Data.Either.Left
                                   @ Scheme.Core.Diagnostic
                                   @ (Scheme.Core.Val,
                                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                                   (Scheme.Core.UnexpectedArgs wild))
                                  `cast`
                                (Sym (Data.Functor.Identity.N:Identity[0]
                                          <Data.Either.Either
                                             Scheme.Core.Diagnostic
                                             (Scheme.Core.Val,
                                              Data.HashMap.Base.HashMap
                                                GHC.Base.String
                                                Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                                <Scheme.Core.Diagnostic>_N
                                                                                <Data.Functor.Identity.Identity>_R
                                                                                <(Scheme.Core.Val,
                                                                                  Data.HashMap.Base.HashMap
                                                                                    GHC.Base.String
                                                                                    Scheme.Core.Val)>_N)) } } }) -}
9e75a10b022b0322fa4dccb44edbbf1f
  liftBoolUnaryOp ::
    (GHC.Types.Bool -> GHC.Types.Bool) -> Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(U)>m6, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Bool -> GHC.Types.Bool) ->
                 case Scheme.Runtime.$wliftBoolUnaryOp w of ww { Unit# ww1 ->
                 Scheme.Core.PrimFunc ww1 }) -}
a21135e6745af313944041a150160c6b
  liftBoolVargOp ::
    ([GHC.Types.Bool] -> GHC.Types.Bool) -> Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(U)>m6, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: [GHC.Types.Bool] -> GHC.Types.Bool) ->
                 case Scheme.Runtime.$wliftBoolVargOp w of ww { Unit# ww1 ->
                 Scheme.Core.PrimFunc ww1 }) -}
ea24e04e06ad00302a51d1718bd7b28d
  liftCompOp ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool)
    -> Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(C1(U))>m6, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool) ->
                 case Scheme.Runtime.$wliftCompOp w of ww { Unit# ww1 ->
                 Scheme.Core.PrimFunc ww1 }) -}
772cdf5e322268aaca4d02e5df862f0f
  liftCompOp1 ::
    [Scheme.Core.Val]
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic ([GHC.Types.Int], Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U> -}
fde24b99565f588bfc6d3becf24f5925
  liftIntBinOp ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
    -> Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(C1(U))>m6, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int) ->
                 case Scheme.Runtime.$wliftIntBinOp w of ww { Unit# ww1 ->
                 Scheme.Core.PrimFunc ww1 }) -}
ed07e939ab352c4053148e80c3ca0c51
  liftIntUnaryOp ::
    (GHC.Types.Int -> GHC.Types.Int) -> Scheme.Core.Val
  {- Arity: 1, HasNoCafRefs, Strictness: <L,C(U)>m6, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int -> GHC.Types.Int) ->
                 case Scheme.Runtime.$wliftIntUnaryOp w of ww { Unit# ww1 ->
                 Scheme.Core.PrimFunc ww1 }) -}
8260188408ddeab51b527deb34e9d75b
  liftIntVargOp ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
    -> GHC.Types.Int -> Scheme.Core.Val
  {- Arity: 2, Strictness: <L,C(C(U))><L,U>m6, Inline: [2],
     Unfolding: InlineRule (2, True, False)
                (\ (w :: GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Int)
                   (w1 :: GHC.Types.Int) ->
                 case Scheme.Runtime.$wliftIntVargOp w w1 of ww { Unit# ww1 ->
                 Scheme.Core.PrimFunc ww1 }) -}
316ce5b962cfacbc665e29d884f74688
  list :: [Scheme.Core.Val] -> Scheme.Core.EvalState Scheme.Core.Val
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.list1
                  `cast`
                (<[Scheme.Core.Val]>_R
                 ->_R (<Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val>_R
                       ->_R Sym (Data.Functor.Identity.N:Identity[0]
                                     <Data.Either.Either
                                        Scheme.Core.Diagnostic
                                        (Scheme.Core.Val,
                                         Data.HashMap.Base.HashMap
                                           GHC.Base.String
                                           Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                           <Scheme.Core.Diagnostic>_N
                                                                           <Data.Functor.Identity.Identity>_R
                                                                           <(Scheme.Core.Val,
                                                                             Data.HashMap.Base.HashMap
                                                                               GHC.Base.String
                                                                               Scheme.Core.Val)>_N)) ; Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                                                                                                                <Data.HashMap.Base.HashMap
                                                                                                                   GHC.Base.String
                                                                                                                   Scheme.Core.Val>_N
                                                                                                                <Control.Monad.Trans.Except.ExceptT
                                                                                                                   Scheme.Core.Diagnostic
                                                                                                                   Data.Functor.Identity.Identity>_R
                                                                                                                <Scheme.Core.Val>_N)) -}
1261cc3236946c167563c3560fe52d38
  list1 ::
    [Scheme.Core.Val]
    -> Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val
    -> Data.Either.Either
         Scheme.Core.Diagnostic
         (Scheme.Core.Val,
          Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m2,
     Unfolding: InlineRule (2, True, False)
                (\ (lst :: [Scheme.Core.Val])
                   (eta :: Data.HashMap.Base.HashMap
                             GHC.Base.String Scheme.Core.Val) ->
                 Data.Either.Right
                   @ Scheme.Core.Diagnostic
                   @ (Scheme.Core.Val,
                      Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                   (Scheme.Core.List lst, eta)) -}
f957fbcdb3dfbf0d86d2dcbf2b98376b
  lowerBool :: Scheme.Core.Val -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: Scheme.Core.Val) ->
                 case ds of wild {
                   DEFAULT -> GHC.Types.True Scheme.Core.Boolean ds1 -> ds1 }) -}
b1d646537ab8d7cefc980c6a514a6a3a
  lowerInt :: Scheme.Core.Val -> Scheme.Core.EvalState GHC.Types.Int
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.lowerInt1
                  `cast`
                (<Scheme.Core.Val>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <GHC.Types.Int>_N)) -}
f5932778e6e8de117abadda0e69a3688
  lowerInt1 ::
    Scheme.Core.Val
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic (GHC.Types.Int, Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Scheme.Core.Val) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   DEFAULT
                   -> (Data.Either.Left
                         @ Scheme.Core.Diagnostic
                         @ (GHC.Types.Int,
                            Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                         (Scheme.Core.TypeError wild))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (GHC.Types.Int,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(GHC.Types.Int,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   Scheme.Core.Number i
                   -> (Data.Either.Right
                         @ Scheme.Core.Diagnostic
                         @ (GHC.Types.Int,
                            Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                         (i, eta))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   (GHC.Types.Int,
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <(GHC.Types.Int,
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N)) }) -}
4e7e0e1e6be8a41957e898687132f4e8
  lowerList ::
    Scheme.Core.Val -> Scheme.Core.EvalState [Scheme.Core.Val]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Scheme.Runtime.lowerList1
                  `cast`
                (<Scheme.Core.Val>_R
                 ->_R Sym (Control.Monad.Trans.State.Lazy.N:StateT[0]
                               <Scheme.Core.Env>_N
                               <Control.Monad.Trans.Except.Except Scheme.Core.Diagnostic>_R
                               <[Scheme.Core.Val]>_N)) -}
7330af3d47208cbe499f1f6bb7e80d56
  lowerList1 ::
    Scheme.Core.Val
    -> Scheme.Core.Env
    -> Control.Monad.Trans.Except.Except
         Scheme.Core.Diagnostic ([Scheme.Core.Val], Scheme.Core.Env)
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: Scheme.Core.Val) (eta :: Scheme.Core.Env) ->
                 case ds of wild {
                   DEFAULT
                   -> (Data.Either.Left
                         @ Scheme.Core.Diagnostic
                         @ ([Scheme.Core.Val],
                            Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                         (Scheme.Core.TypeError wild))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   ([Scheme.Core.Val],
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <([Scheme.Core.Val],
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N))
                   Scheme.Core.List xx
                   -> (Data.Either.Right
                         @ Scheme.Core.Diagnostic
                         @ ([Scheme.Core.Val],
                            Data.HashMap.Base.HashMap GHC.Base.String Scheme.Core.Val)
                         (xx, eta))
                        `cast`
                      (Sym (Data.Functor.Identity.N:Identity[0]
                                <Data.Either.Either
                                   Scheme.Core.Diagnostic
                                   ([Scheme.Core.Val],
                                    Data.HashMap.Base.HashMap
                                      GHC.Base.String
                                      Scheme.Core.Val)>_R) ; Sym (Control.Monad.Trans.Except.N:ExceptT[0]
                                                                      <Scheme.Core.Diagnostic>_N
                                                                      <Data.Functor.Identity.Identity>_R
                                                                      <([Scheme.Core.Val],
                                                                        Data.HashMap.Base.HashMap
                                                                          GHC.Base.String
                                                                          Scheme.Core.Val)>_N)) }) -}
e0b32da9d630681dfc92301929c5c088
  myFoldl1 ::
    (GHC.Types.Int -> GHC.Types.Int -> GHC.Types.Bool)
    -> [GHC.Types.Int] -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <L,C(C1(U))><S,1*U> -}
3dac289df52f08944958b67b00b04972
  runtime :: Scheme.Core.Env
"SPEC/Scheme.Runtime $wupdateOrSnocWithKey @ [Char] _" [orphan] [2] forall @ v
                                                                           (w :: GHC.Classes.Eq
                                                                                   [GHC.Types.Char])
  Data.HashMap.Base.$wupdateOrSnocWithKey @ [GHC.Types.Char] @ v w
  = Scheme.Runtime.$s$wupdateOrSnocWithKey @ v
"SPEC/Scheme.Runtime unsafeInsert @ [Char] _" [orphan] forall @ v
                                                              ($dHashable :: Data.Hashable.Class.Hashable
                                                                               [GHC.Types.Char])
                                                              ($dEq :: GHC.Classes.Eq
                                                                         [GHC.Types.Char])
  Data.HashMap.Base.unsafeInsert @ [GHC.Types.Char]
                                 @ v
                                 $dEq
                                 $dHashable
  = Scheme.Runtime.$sunsafeInsert @ v
trusted: safe
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

